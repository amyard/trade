@page "/trading-pairs"
@rendermode InteractiveServer
@using global::MarketParse.Services
@using global::MarketParse.Models
@using CryptoExchange.Net.Objects.Sockets
@inject TradingPairsService TradingPairsService
@inject BinanceFuturesService BinanceService
@inject NavigationManager Navigation
@inject ILogger<TradingPairs> Logger
@implements IDisposable

<PageTitle>Trading Pairs</PageTitle>

<h1>Trading Pairs</h1>

<div class="mb-3">
    <div class="row">
        <div class="col-md-6">
            <input type="text" 
                   class="form-control" 
                   placeholder="Search trading pairs..." 
                   @bind="searchQuery" 
                   @bind:event="oninput"
                   @onkeyup="FilterPairs" />
        </div>
        <div class="col-md-6 d-flex align-items-center justify-content-end">
            <span class="text-muted me-3">Total pairs: @filteredPairs.Count</span>
            
            @if (isWebSocketConnected)
            {
                <span class="badge bg-success me-2">
                    <span class="live-indicator"></span> LIVE
                </span>
                <button class="btn btn-danger btn-sm me-2" @onclick="StopRealtimePrices">
                    Stop Real-Time
                </button>
            }
            else
            {
                <span class="badge bg-secondary me-2">
                    Offline
                </span>
                <button class="btn btn-success btn-sm me-2" @onclick="StartRealtimePrices" disabled="@isLoadingPrices">
                    @if (isLoadingPrices)
                    {
                        <span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>
                    }
                    Start Real-Time
                </button>
            }
            
            <button class="btn btn-primary btn-sm" @onclick="LoadPrices" disabled="@isLoadingPrices">
                @if (isLoadingPrices)
                {
                    <span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>
                }
                Refresh
            </button>
        </div>
    </div>
</div>

@if (isLoadingPrices && prices.Count == 0)
{
    <div class="text-center my-5">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <p class="mt-2">Loading prices...</p>
    </div>
}
else if (filteredPairs.Any())
{
    <div class="table-responsive">
        <table class="table table-hover">
            <thead class="table-light">
                <tr>
                    <th>#</th>
                    <th>Symbol</th>
                    <th>Pair</th>
                    <th class="text-end">Current Price (USDT)</th>
                    <th class="text-center">Action</th>
                </tr>
            </thead>
            <tbody>
                @{
                    int index = 1;
                }
                @foreach (var pair in filteredPairs)
                {
                    var hasPrice = prices.TryGetValue(pair.Symbol, out var price);
                    var priceClass = GetPriceChangeClass(pair.Symbol);
                    
                    <tr class="trading-pair-row" @onclick="() => NavigateToPairDetails(pair.Symbol)">
                        <td>@index</td>
                        <td><strong>@pair.Symbol</strong></td>
                        <td>
                            <span class="badge bg-secondary">@pair.BaseAsset</span>
                            <span class="mx-1">/</span>
                            <span class="badge bg-info">@pair.QuoteAsset</span>
                        </td>
                        <td class="text-end">
                            @if (hasPrice)
                            {
                                <span class="price-value @priceClass">
                                    $@price.ToString("N2")
                                </span>
                            }
                            else if (isLoadingPrices)
                            {
                                <span class="spinner-border spinner-border-sm" role="status"></span>
                            }
                            else
                            {
                                <span class="text-muted">-</span>
                            }
                        </td>
                        <td class="text-center">
                            <button class="btn btn-primary btn-sm" @onclick:stopPropagation="true" @onclick="() => NavigateToPairDetails(pair.Symbol)">
                                View Details
                            </button>
                        </td>
                    </tr>
                    index++;
                }
            </tbody>
        </table>
    </div>

    <div class="d-flex justify-content-between align-items-center mt-2">
        @if (lastUpdateTime.HasValue)
        {
            <div class="text-muted small">
                Last updated: @lastUpdateTime.Value.ToString("HH:mm:ss")
            </div>
        }
        @if (isWebSocketConnected)
        {
            <div class="text-success small">
                <i class="bi bi-wifi"></i> Real-time updates active
            </div>
        }
    </div>
}
else
{
    <div class="alert alert-info">
        No trading pairs found matching "@searchQuery"
    </div>
}

<style>
    .trading-pair-row {
        cursor: pointer;
        transition: background-color 0.2s;
    }

    .trading-pair-row:hover {
        background-color: rgba(0, 123, 255, 0.05);
    }

    .price-value {
        font-weight: 600;
        font-size: 1.1rem;
        color: #0d6efd;
        transition: all 0.3s ease;
    }

    .price-up {
        color: #28a745 !important;
        animation: priceFlashGreen 0.5s ease;
    }

    .price-down {
        color: #dc3545 !important;
        animation: priceFlashRed 0.5s ease;
    }

    @@keyframes priceFlashGreen {
        0%, 100% { background-color: transparent; }
        50% { background-color: rgba(40, 167, 69, 0.2); }
    }

    @@keyframes priceFlashRed {
        0%, 100% { background-color: transparent; }
        50% { background-color: rgba(220, 53, 69, 0.2); }
    }

    .badge {
        font-size: 0.85rem;
        padding: 0.35rem 0.65rem;
    }

    .table th {
        font-weight: 600;
        border-bottom: 2px solid #dee2e6;
    }

    .live-indicator {
        display: inline-block;
        width: 8px;
        height: 8px;
        background-color: white;
        border-radius: 50%;
        animation: pulse 1.5s ease-in-out infinite;
        margin-right: 5px;
    }

    @@keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.3; }
    }
</style>

@code {
    private List<TradingPair> allPairs = new();
    private List<TradingPair> filteredPairs = new();
    private Dictionary<string, decimal> prices = new();
    private Dictionary<string, decimal> previousPrices = new();
    private Dictionary<string, DateTime> priceChangeTime = new();
    private string searchQuery = string.Empty;
    private bool isLoadingPrices = false;
    private bool isWebSocketConnected = false;
    private DateTime? lastUpdateTime;
    private UpdateSubscription? priceSubscription;

    protected override async Task OnInitializedAsync()
    {
        allPairs = TradingPairsService.GetAllTradingPairs();
        filteredPairs = allPairs;
        
        // Auto-start real-time updates
        await StartRealtimePrices();
    }

    private async Task LoadPrices()
    {
        isLoadingPrices = true;
        StateHasChanged();

        try
        {
            var symbols = allPairs.Select(p => p.Symbol).ToList();
            prices = await BinanceService.GetCurrentPricesAsync(symbols);
            lastUpdateTime = DateTime.Now;
            
            Logger.LogInformation($"Loaded prices for {prices.Count} trading pairs");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading prices");
        }
        finally
        {
            isLoadingPrices = false;
            StateHasChanged();
        }
    }

    private async Task StartRealtimePrices()
    {
        if (isWebSocketConnected)
            return;

        isLoadingPrices = true;
        StateHasChanged();

        try
        {
            // Load initial prices first
            await LoadPrices();

            // Subscribe to real-time price updates
            var symbols = allPairs.Select(p => p.Symbol).ToList();
            priceSubscription = await BinanceService.SubscribeToPriceUpdatesAsync(symbols, OnPriceUpdate);

            if (priceSubscription is not null)
            {
                isWebSocketConnected = true;
                Logger.LogInformation("Real-time price updates started automatically");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error starting real-time price updates");
        }
        finally
        {
            isLoadingPrices = false;
            StateHasChanged();
        }
    }

    private async Task StopRealtimePrices()
    {
        if (priceSubscription is not null)
        {
            await BinanceService.UnsubscribeAsync(priceSubscription);
            priceSubscription = null;
            isWebSocketConnected = false;
            Logger.LogInformation("Real-time price updates stopped");
            StateHasChanged();
        }
    }

    private void OnPriceUpdate(string symbol, decimal newPrice)
    {
        // Store previous price for comparison
        if (prices.TryGetValue(symbol, out var oldPrice))
        {
            previousPrices[symbol] = oldPrice;
        }

        // Update price
        prices[symbol] = newPrice;
        priceChangeTime[symbol] = DateTime.Now;
        lastUpdateTime = DateTime.Now;

        // Update UI
        InvokeAsync(StateHasChanged);

        // Clear price change indicator after 1 second
        _ = Task.Run(async () =>
        {
            await Task.Delay(1000);
            priceChangeTime.Remove(symbol);
            await InvokeAsync(StateHasChanged);
        });
    }

    private string GetPriceChangeClass(string symbol)
    {
        if (!priceChangeTime.ContainsKey(symbol))
            return string.Empty;

        if (!previousPrices.TryGetValue(symbol, out var prevPrice) || !prices.TryGetValue(symbol, out var currentPrice))
            return string.Empty;

        if (currentPrice > prevPrice)
            return "price-up";
        else if (currentPrice < prevPrice)
            return "price-down";

        return string.Empty;
    }

    private void FilterPairs()
    {
        if (string.IsNullOrWhiteSpace(searchQuery))
        {
            filteredPairs = allPairs;
        }
        else
        {
            filteredPairs = TradingPairsService.SearchTradingPairs(searchQuery);
        }
        StateHasChanged();
    }

    private void NavigateToPairDetails(string symbol)
    {
        Navigation.NavigateTo($"/trading-pair/{symbol}");
    }

    public void Dispose()
    {
        if (priceSubscription is not null)
        {
            _ = StopRealtimePrices();
        }
    }
}
