@page "/trading-pairs"
@rendermode InteractiveServer
@using global::MarketParse.Services
@using global::MarketParse.Models
@using CryptoExchange.Net.Objects.Sockets
@using System.Collections.Concurrent
@inject TradingPairsService TradingPairsService
@inject BinanceFuturesService BinanceService
@inject NavigationManager Navigation
@inject ILogger<TradingPairs> Logger
@implements IAsyncDisposable

<PageTitle>Trading Pairs</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraLarge" Class="mt-4">
    <MudText Typo="Typo.h3" Class="mb-4">Trading Pairs</MudText>

    <MudPaper Class="pa-4 mb-4">
        <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
            <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                @if (isWebSocketConnected)
                {
                    <MudChip T="string" Color="Color.Success" Icon="@Icons.Material.Filled.Wifi" Size="Size.Small">LIVE</MudChip>
                    <MudButton Variant="Variant.Filled" Color="Color.Error" Size="Size.Small" OnClick="StopRealtimePrices">
                        Stop Real-Time
                    </MudButton>
                }
                else
                {
                    <MudChip T="string" Color="Color.Default" Icon="@Icons.Material.Filled.WifiOff" Size="Size.Small">Offline</MudChip>
                    <MudButton Variant="Variant.Filled" Color="Color.Success" Size="Size.Small" OnClick="StartRealtimePrices" Disabled="@isLoadingPrices">
                        @if (isLoadingPrices)
                        {
                            <MudProgressCircular Class="mr-2" Size="Size.Small" Indeterminate="true" />
                        }
                        Start Real-Time
                    </MudButton>
                }
                
                <MudButton Variant="Variant.Filled" Color="Color.Primary" Size="Size.Small" OnClick="LoadPrices" Disabled="@isLoadingPrices" StartIcon="@Icons.Material.Filled.Refresh">
                    @if (isLoadingPrices)
                    {
                        <MudProgressCircular Class="mr-2" Size="Size.Small" Indeterminate="true" />
                    }
                    Refresh
                </MudButton>
            </MudStack>

            @if (lastUpdateTime.HasValue)
            {
                <MudText Typo="Typo.caption" Color="Color.Secondary">
                    Last updated: @lastUpdateTime.Value.ToString("HH:mm:ss")
                </MudText>
            }
        </MudStack>
    </MudPaper>

    @if (isLoadingPrices && prices.Count == 0)
    {
        <MudPaper Class="pa-8">
            <MudStack AlignItems="AlignItems.Center" Spacing="3">
                <MudProgressCircular Color="Color.Primary" Size="Size.Large" Indeterminate="true" />
                <MudText Typo="Typo.h6">Loading prices...</MudText>
            </MudStack>
        </MudPaper>
    }
    else
    {
        <MudTable Items="@allPairs" 
                  Dense="true" 
                  Hover="true" 
                  Striped="true" 
                  Breakpoint="Breakpoint.Sm"
                  Loading="@isLoadingPrices" 
                  LoadingProgressColor="Color.Primary"
                  Filter="new Func<TradingPair, bool>(FilterFunc)"
                  @bind-SelectedItem="selectedPair"
                  T="TradingPair">
            <ToolBarContent>
                <MudText Typo="Typo.h6">Trading Pairs</MudText>
                <MudSpacer />
                <MudTextField @bind-Value="searchString" 
                              Placeholder="Search pairs..." 
                              Adornment="Adornment.Start" 
                              AdornmentIcon="@Icons.Material.Filled.Search" 
                              IconSize="Size.Medium" 
                              Class="mt-0"
                              Immediate="true"
                              Clearable="true"></MudTextField>
            </ToolBarContent>
            <HeaderContent>
                <MudTh><MudTableSortLabel SortBy="new Func<TradingPair, object>(x => x.Symbol)">Symbol</MudTableSortLabel></MudTh>
                <MudTh><MudTableSortLabel SortBy="new Func<TradingPair, object>(x => (int)x.Priority)">Priority</MudTableSortLabel></MudTh>
                <MudTh><MudTableSortLabel SortBy="new Func<TradingPair, object>(x => GetPrice(x.Symbol))">Current Price (USDT)</MudTableSortLabel></MudTh>
                <MudTh><MudTableSortLabel SortBy="new Func<TradingPair, object>(x => GetRsi(x.Symbol))">RSI(14)</MudTableSortLabel></MudTh>
                <MudTh><MudTableSortLabel SortBy="new Func<TradingPair, object>(x => GetVolume(x.Symbol))">24h Volume (USDT)</MudTableSortLabel></MudTh>
                <MudTh><MudTableSortLabel SortBy="new Func<TradingPair, object>(x => GetTradeCount(x.Symbol))">24h Trades</MudTableSortLabel></MudTh>
                <MudTh>Update Priority</MudTh>
                <MudTh>Action</MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd DataLabel="Symbol">
                    <MudText Typo="Typo.body2"><strong>@context.Symbol</strong></MudText>
                </MudTd>
                <MudTd DataLabel="Priority">
                    @{
                        var priorityColor = context.Priority switch
                        {
                            Priority.High => Color.Error,
                            Priority.Average => Color.Warning,
                            Priority.Low => Color.Info,
                            _ => Color.Default
                        };
                    }
                    <MudChip T="string" Color="@priorityColor" Size="Size.Small">@context.Priority.ToString()</MudChip>
                </MudTd>
                <MudTd DataLabel="Current Price">
                    @if (prices.TryGetValue(context.Symbol, out var price))
                    {
                        var priceClass = GetPriceChangeClass(context.Symbol);
                        <MudText Typo="Typo.body2" Color="@(priceClass == "price-up" ? Color.Success : priceClass == "price-down" ? Color.Error : Color.Primary)">
                            <strong>$@price.ToString("N2")</strong>
                        </MudText>
                    }
                    else if (isLoadingPrices)
                    {
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                    }
                    else
                    {
                        <MudText Typo="Typo.body2" Color="Color.Secondary">-</MudText>
                    }
                </MudTd>
                <MudTd DataLabel="RSI(14)">
                    @if (rsiValues.TryGetValue(context.Symbol, out var rsi))
                    {
                        var rsiColor = rsi switch
                        {
                            >= 70 => Color.Error,
                            <= 30 => Color.Success,
                            _ => Color.Default
                        };
                        <MudChip T="string" Color="@rsiColor" Size="Size.Small">
                            @rsi.ToString("N2")
                        </MudChip>
                    }
                    else if (isLoadingPrices)
                    {
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                    }
                    else
                    {
                        <MudText Typo="Typo.body2" Color="Color.Secondary">-</MudText>
                    }
                </MudTd>
                <MudTd DataLabel="24h Volume">
                    @if (volumes.TryGetValue(context.Symbol, out var volume))
                    {
                        <MudText Typo="Typo.body2">$@FormatVolume(volume)</MudText>
                    }
                    else if (isLoadingPrices)
                    {
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                    }
                    else
                    {
                        <MudText Typo="Typo.body2" Color="Color.Secondary">-</MudText>
                    }
                </MudTd>
                <MudTd DataLabel="24h Trades">
                    @if (tradeCounts.TryGetValue(context.Symbol, out var count))
                    {
                        <MudText Typo="Typo.body2">@count.ToString("N0")</MudText>
                    }
                    else if (isLoadingPrices)
                    {
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                    }
                    else
                    {
                        <MudText Typo="Typo.body2" Color="Color.Secondary">-</MudText>
                    }
                </MudTd>
                <MudTd DataLabel="Update Priority">
                    <MudButton Variant="Variant.Outlined" 
                               Color="Color.Secondary" 
                               Size="Size.Small" 
                               OnClick="@(() => OpenPriorityDialog(context))"
                               StartIcon="@Icons.Material.Filled.Edit">
                        Update
                    </MudButton>
                </MudTd>
                <MudTd DataLabel="Action">
                    <MudButton Variant="Variant.Filled" 
                               Color="Color.Primary" 
                               Size="Size.Small" 
                               OnClick="@(() => NavigateToPairDetails(context.Symbol))"
                               StartIcon="@Icons.Material.Filled.TrendingUp">
                        View Details
                    </MudButton>
                </MudTd>
            </RowTemplate>
            <PagerContent>
                <MudTablePager PageSizeOptions="new int[]{10, 25, 50, 100}" />
            </PagerContent>
        </MudTable>
    }
</MudContainer>

<MudOverlay Visible="showPriorityDialog" DarkBackground="true" ZIndex="9999">
    <MudPaper Class="pa-6" Style="width: 400px; max-width: 90vw;">
        <MudText Typo="Typo.h6" Class="mb-4">Update Priority for @(selectedPairForPriority?.Symbol ?? "")</MudText>
        
        <MudSelect @bind-Value="selectedPriorityValue" T="Priority" Label="Select Priority" Variant="Variant.Outlined" Class="mb-4">
            <MudSelectItem Value="Priority.High">
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                    <MudChip T="string" Color="Color.Error" Size="Size.Small">High</MudChip>
                    <MudText>High Priority</MudText>
                </MudStack>
            </MudSelectItem>
            <MudSelectItem Value="Priority.Average">
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                    <MudChip T="string" Color="Color.Warning" Size="Size.Small">Average</MudChip>
                    <MudText>Average Priority</MudText>
                </MudStack>
            </MudSelectItem>
            <MudSelectItem Value="Priority.Low">
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                    <MudChip T="string" Color="Color.Info" Size="Size.Small">Low</MudChip>
                    <MudText>Low Priority</MudText>
                </MudStack>
            </MudSelectItem>
            <MudSelectItem Value="Priority.None">
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                    <MudChip T="string" Color="Color.Default" Size="Size.Small">None</MudChip>
                    <MudText>No Priority</MudText>
                </MudStack>
            </MudSelectItem>
        </MudSelect>
        
        <MudStack Row="true" Justify="Justify.FlexEnd" Spacing="2">
            <MudButton OnClick="ClosePriorityDialog">Cancel</MudButton>
            <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="SavePriority">Save</MudButton>
        </MudStack>
    </MudPaper>
</MudOverlay>

@code {
    private List<TradingPair> allPairs = new();
    private ConcurrentDictionary<string, decimal> prices = new();
    private ConcurrentDictionary<string, decimal> volumes = new();
    private ConcurrentDictionary<string, long> tradeCounts = new();
    private ConcurrentDictionary<string, decimal> rsiValues = new();
    private ConcurrentDictionary<string, decimal> previousPrices = new();
    private ConcurrentDictionary<string, DateTime> priceChangeTime = new();
    private string searchString = string.Empty;
    private bool isLoadingPrices = false;
    private bool isWebSocketConnected = false;
    private DateTime? lastUpdateTime;
    private UpdateSubscription? priceSubscription;
    private TradingPair? selectedPair;
    private CancellationTokenSource? _cts;
    private bool _disposed = false;

    private bool showPriorityDialog = false;
    private TradingPair? selectedPairForPriority;
    private Priority selectedPriorityValue;

    protected override async Task OnInitializedAsync()
    {
        _cts = new CancellationTokenSource();
        allPairs = TradingPairsService.GetAllTradingPairs();
        
        // Auto-start real-time updates
        await StartRealtimePrices();
    }

    private void OpenPriorityDialog(TradingPair pair)
    {
        selectedPairForPriority = pair;
        selectedPriorityValue = pair.Priority;
        showPriorityDialog = true;
    }

    private void ClosePriorityDialog()
    {
        showPriorityDialog = false;
        selectedPairForPriority = null;
    }

    private async Task SavePriority()
    {
        if (selectedPairForPriority != null)
        {
            var success = await TradingPairsService.UpdatePriorityAsync(
                selectedPairForPriority.Symbol, 
                selectedPriorityValue);
            
            if (success)
            {
                Logger.LogInformation($"Successfully updated priority for {selectedPairForPriority.Symbol} to {selectedPriorityValue}");
                StateHasChanged();
            }
            else
            {
                Logger.LogError($"Failed to update priority for {selectedPairForPriority.Symbol}");
            }
        }
        ClosePriorityDialog();
    }

    private async Task LoadPrices()
    {
        if (_disposed) return;
        
        isLoadingPrices = true;
        StateHasChanged();

        try
        {
            var symbols = allPairs.Select(p => p.Symbol).ToList();
            
            // Load prices, volumes, trade counts and RSI in parallel
            var pricesTask = BinanceService.GetCurrentPricesAsync(symbols);
            var volumesTask = BinanceService.Get24HourVolumesAsync(symbols);
            var tradeCountsTask = BinanceService.Get24HourTradeCountsAsync(symbols);
            var rsiTask = BinanceService.CalculateRsiForSymbolsAsync(symbols, 14);
            
            await Task.WhenAll(pricesTask, volumesTask, tradeCountsTask, rsiTask);
            
            var pricesResult = await pricesTask;
            var volumesResult = await volumesTask;
            var tradeCountsResult = await tradeCountsTask;
            var rsiResult = await rsiTask;
            
            // Clear and update concurrent dictionaries
            prices.Clear();
            volumes.Clear();
            tradeCounts.Clear();
            rsiValues.Clear();
            
            foreach (var kvp in pricesResult)
                prices.TryAdd(kvp.Key, kvp.Value);
            
            foreach (var kvp in volumesResult)
                volumes.TryAdd(kvp.Key, kvp.Value);
            
            foreach (var kvp in tradeCountsResult)
                tradeCounts.TryAdd(kvp.Key, kvp.Value);
            
            foreach (var kvp in rsiResult)
                rsiValues.TryAdd(kvp.Key, kvp.Value);
            
            lastUpdateTime = DateTime.Now;
            
            Logger.LogInformation($"Loaded prices, volumes, trade counts and RSI for {prices.Count} trading pairs");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading prices, volumes, trade counts and RSI");
        }
        finally
        {
            isLoadingPrices = false;
            if (!_disposed)
            {
                StateHasChanged();
            }
        }
    }

    private async Task StartRealtimePrices()
    {
        if (isWebSocketConnected || _disposed)
            return;

        isLoadingPrices = true;
        StateHasChanged();

        try
        {
            // Load initial prices first
            await LoadPrices();

            if (_disposed) return;

            // Subscribe to real-time price updates
            var symbols = allPairs.Select(p => p.Symbol).ToList();
            priceSubscription = await BinanceService.SubscribeToPriceUpdatesAsync(symbols, OnPriceUpdate);

            if (priceSubscription is not null && !_disposed)
            {
                isWebSocketConnected = true;
                Logger.LogInformation("Real-time price updates started automatically");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error starting real-time price updates");
        }
        finally
        {
            isLoadingPrices = false;
            if (!_disposed)
            {
                StateHasChanged();
            }
        }
    }

    private async Task StopRealtimePrices()
    {
        if (priceSubscription is not null)
        {
            try
            {
                await BinanceService.UnsubscribeAsync(priceSubscription);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error stopping real-time price updates");
            }
            finally
            {
                priceSubscription = null;
                isWebSocketConnected = false;
                Logger.LogInformation("Real-time price updates stopped");
                if (!_disposed)
                {
                    StateHasChanged();
                }
            }
        }
    }

    private void OnPriceUpdate(string symbol, decimal newPrice)
    {
        if (_disposed) return;

        try
        {
            // Store previous price for comparison
            if (prices.TryGetValue(symbol, out var oldPrice))
            {
                previousPrices.AddOrUpdate(symbol, oldPrice, (key, existing) => oldPrice);
            }

            // Update price using thread-safe method
            prices.AddOrUpdate(symbol, newPrice, (key, existing) => newPrice);
            priceChangeTime.AddOrUpdate(symbol, DateTime.Now, (key, existing) => DateTime.Now);
            lastUpdateTime = DateTime.Now;

            // Recalculate RSI asynchronously when price updates
            _ = Task.Run(async () =>
            {
                try
                {
                    var rsi = await BinanceService.CalculateRsiAsync(symbol, 14);
                    if (rsi.HasValue)
                    {
                        rsiValues.AddOrUpdate(symbol, rsi.Value, (key, existing) => rsi.Value);
                        await InvokeAsync(StateHasChanged);
                    }
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Error recalculating RSI for {Symbol}", symbol);
                }
            });

            // Update UI
            _ = InvokeAsync(StateHasChanged);

            // Clear price change indicator after 1 second
            _ = Task.Delay(1000, _cts?.Token ?? CancellationToken.None)
                .ContinueWith(_ =>
                {
                    if (!_disposed && !(_cts?.Token.IsCancellationRequested ?? true))
                    {
                        priceChangeTime.TryRemove(symbol, out DateTime _);
                        _ = InvokeAsync(StateHasChanged);
                    }
                }, TaskScheduler.Default);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error in OnPriceUpdate for symbol {Symbol}", symbol);
        }
    }

    private string GetPriceChangeClass(string symbol)
    {
        if (!priceChangeTime.ContainsKey(symbol))
            return string.Empty;

        if (!previousPrices.TryGetValue(symbol, out var prevPrice) || !prices.TryGetValue(symbol, out var currentPrice))
            return string.Empty;

        if (currentPrice > prevPrice)
            return "price-up";
        else if (currentPrice < prevPrice)
            return "price-down";

        return string.Empty;
    }

    private decimal GetPrice(string symbol)
    {
        return prices.TryGetValue(symbol, out var price) ? price : 0m;
    }

    private decimal GetRsi(string symbol)
    {
        return rsiValues.TryGetValue(symbol, out var rsi) ? rsi : 0m;
    }

    private decimal GetVolume(string symbol)
    {
        return volumes.TryGetValue(symbol, out var volume) ? volume : 0m;
    }

    private long GetTradeCount(string symbol)
    {
        return tradeCounts.TryGetValue(symbol, out var count) ? count : 0;
    }

    private string FormatVolume(decimal volume)
    {
        if (volume >= 1_000_000_000)
            return $"{(volume / 1_000_000_000):N2}B";
        if (volume >= 1_000_000)
            return $"{(volume / 1_000_000):N2}M";
        if (volume >= 1_000)
            return $"{(volume / 1_000):N2}K";
        return volume.ToString("N2");
    }

    private bool FilterFunc(TradingPair pair)
    {
        if (string.IsNullOrWhiteSpace(searchString))
            return true;

        if (pair.Symbol.Contains(searchString, StringComparison.OrdinalIgnoreCase))
            return true;
        if (pair.BaseAsset.Contains(searchString, StringComparison.OrdinalIgnoreCase))
            return true;
        if (pair.QuoteAsset.Contains(searchString, StringComparison.OrdinalIgnoreCase))
            return true;
        if (pair.DisplayName.Contains(searchString, StringComparison.OrdinalIgnoreCase))
            return true;
        if (!string.IsNullOrEmpty(pair.FullName) && pair.FullName.Contains(searchString, StringComparison.OrdinalIgnoreCase))
            return true;

        return false;
    }

    private void OnRowClick(TableRowClickEventArgs<TradingPair> args)
    {
        NavigateToPairDetails(args.Item.Symbol);
    }

    private void NavigateToPairDetails(string symbol)
    {
        Navigation.NavigateTo($"/trading-pair/{symbol}");
    }

    public async ValueTask DisposeAsync()
    {
        if (_disposed) return;
        
        _disposed = true;
        
        // Cancel all pending tasks
        _cts?.Cancel();
        _cts?.Dispose();
        
        // Stop WebSocket subscription
        if (priceSubscription is not null)
        {
            await StopRealtimePrices();
        }
    }
}
