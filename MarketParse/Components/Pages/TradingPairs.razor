@page "/trading-pairs"
@rendermode InteractiveServer
@using global::MarketParse.Services
@using global::MarketParse.Models
@using CryptoExchange.Net.Objects.Sockets
@inject TradingPairsService TradingPairsService
@inject BinanceFuturesService BinanceService
@inject NavigationManager Navigation
@inject ILogger<TradingPairs> Logger
@implements IAsyncDisposable

<PageTitle>Trading Pairs</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraLarge" Class="mt-4">
    <MudText Typo="Typo.h3" Class="mb-4">Trading Pairs</MudText>

    <MudPaper Class="pa-4 mb-4">
        <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
            <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                @if (isWebSocketConnected)
                {
                    <MudChip T="string" Color="Color.Success" Icon="@Icons.Material.Filled.Wifi" Size="Size.Small">LIVE</MudChip>
                    <MudButton Variant="Variant.Filled" Color="Color.Error" Size="Size.Small" OnClick="StopRealtimePrices">
                        Stop Real-Time
                    </MudButton>
                }
                else
                {
                    <MudChip T="string" Color="Color.Default" Icon="@Icons.Material.Filled.WifiOff" Size="Size.Small">Offline</MudChip>
                    <MudButton Variant="Variant.Filled" Color="Color.Success" Size="Size.Small" OnClick="StartRealtimePrices" Disabled="@isLoadingPrices">
                        @if (isLoadingPrices)
                        {
                            <MudProgressCircular Class="mr-2" Size="Size.Small" Indeterminate="true" />
                        }
                        Start Real-Time
                    </MudButton>
                }
                
                <MudButton Variant="Variant.Filled" Color="Color.Primary" Size="Size.Small" OnClick="LoadPrices" Disabled="@isLoadingPrices" StartIcon="@Icons.Material.Filled.Refresh">
                    @if (isLoadingPrices)
                    {
                        <MudProgressCircular Class="mr-2" Size="Size.Small" Indeterminate="true" />
                    }
                    Refresh
                </MudButton>
            </MudStack>

            @if (lastUpdateTime.HasValue)
            {
                <MudText Typo="Typo.caption" Color="Color.Secondary">
                    Last updated: @lastUpdateTime.Value.ToString("HH:mm:ss")
                </MudText>
            }
        </MudStack>
    </MudPaper>

    @if (isLoadingPrices && prices.Count == 0)
    {
        <MudPaper Class="pa-8">
            <MudStack AlignItems="AlignItems.Center" Spacing="3">
                <MudProgressCircular Color="Color.Primary" Size="Size.Large" Indeterminate="true" />
                <MudText Typo="Typo.h6">Loading prices...</MudText>
            </MudStack>
        </MudPaper>
    }
    else
    {
        <MudTable Items="@allPairs" 
                  Dense="true" 
                  Hover="true" 
                  Striped="true" 
                  Breakpoint="Breakpoint.Sm"
                  Loading="@isLoadingPrices" 
                  LoadingProgressColor="Color.Primary"
                  Filter="new Func<TradingPair, bool>(FilterFunc)"
                  @bind-SelectedItem="selectedPair"
                  OnRowClick="OnRowClick"
                  T="TradingPair">
            <ToolBarContent>
                <MudText Typo="Typo.h6">Trading Pairs</MudText>
                <MudSpacer />
                <MudTextField @bind-Value="searchString" 
                              Placeholder="Search pairs..." 
                              Adornment="Adornment.Start" 
                              AdornmentIcon="@Icons.Material.Filled.Search" 
                              IconSize="Size.Medium" 
                              Class="mt-0"
                              Immediate="true"
                              Clearable="true"></MudTextField>
            </ToolBarContent>
            <HeaderContent>
                <MudTh><MudTableSortLabel SortBy="new Func<TradingPair, object>(x => x.Symbol)">Symbol</MudTableSortLabel></MudTh>
                <MudTh><MudTableSortLabel SortBy="new Func<TradingPair, object>(x => GetPrice(x.Symbol))">Current Price (USDT)</MudTableSortLabel></MudTh>
                <MudTh><MudTableSortLabel SortBy="new Func<TradingPair, object>(x => GetVolume(x.Symbol))">24h Volume (USDT)</MudTableSortLabel></MudTh>
                <MudTh><MudTableSortLabel SortBy="new Func<TradingPair, object>(x => (object)GetTradeCount(x.Symbol))">24h Trades</MudTableSortLabel></MudTh>
                <MudTh>Action</MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd DataLabel="Symbol">
                    <MudText Typo="Typo.body2"><strong>@context.Symbol</strong></MudText>
                </MudTd>
                <MudTd DataLabel="Current Price">
                    @if (prices.TryGetValue(context.Symbol, out var price))
                    {
                        var priceClass = GetPriceChangeClass(context.Symbol);
                        <MudText Typo="Typo.body2" Color="@(priceClass == "price-up" ? Color.Success : priceClass == "price-down" ? Color.Error : Color.Primary)">
                            <strong>$@price.ToString("N2")</strong>
                        </MudText>
                    }
                    else if (isLoadingPrices)
                    {
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                    }
                    else
                    {
                        <MudText Typo="Typo.body2" Color="Color.Secondary">-</MudText>
                    }
                </MudTd>
                <MudTd DataLabel="24h Volume">
                    @if (volumes.TryGetValue(context.Symbol, out var volume))
                    {
                        <MudText Typo="Typo.body2">$@FormatVolume(volume)</MudText>
                    }
                    else if (isLoadingPrices)
                    {
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                    }
                    else
                    {
                        <MudText Typo="Typo.body2" Color="Color.Secondary">-</MudText>
                    }
                </MudTd>
                <MudTd DataLabel="24h Trades">
                    @if (tradeCounts.TryGetValue(context.Symbol, out var count))
                    {
                        <MudText Typo="Typo.body2">@count.ToString("N0")</MudText>
                    }
                    else if (isLoadingPrices)
                    {
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                    }
                    else
                    {
                        <MudText Typo="Typo.body2" Color="Color.Secondary">-</MudText>
                    }
                </MudTd>
                <MudTd DataLabel="Action">
                    <MudButton Variant="Variant.Filled" 
                               Color="Color.Primary" 
                               Size="Size.Small" 
                               OnClick="@(() => NavigateToPairDetails(context.Symbol))"
                               StartIcon="@Icons.Material.Filled.TrendingUp">
                        View Details
                    </MudButton>
                </MudTd>
            </RowTemplate>
            <PagerContent>
                <MudTablePager PageSizeOptions="new int[]{10, 25, 50, 100}" />
            </PagerContent>
        </MudTable>
    }
</MudContainer>

@code {
    private List<TradingPair> allPairs = new();
    private Dictionary<string, decimal> prices = new();
    private Dictionary<string, decimal> volumes = new();
    private Dictionary<string, long> tradeCounts = new();
    private Dictionary<string, decimal> previousPrices = new();
    private Dictionary<string, DateTime> priceChangeTime = new();
    private string searchString = string.Empty;
    private bool isLoadingPrices = false;
    private bool isWebSocketConnected = false;
    private DateTime? lastUpdateTime;
    private UpdateSubscription? priceSubscription;
    private TradingPair? selectedPair;
    private CancellationTokenSource? _cts;
    private bool _disposed = false;

    protected override async Task OnInitializedAsync()
    {
        _cts = new CancellationTokenSource();
        allPairs = TradingPairsService.GetAllTradingPairs();
        
        // Auto-start real-time updates
        await StartRealtimePrices();
    }

    private async Task LoadPrices()
    {
        if (_disposed) return;
        
        isLoadingPrices = true;
        StateHasChanged();

        try
        {
            var symbols = allPairs.Select(p => p.Symbol).ToList();
            
            // Load prices, volumes and trade counts in parallel
            var pricesTask = BinanceService.GetCurrentPricesAsync(symbols);
            var volumesTask = BinanceService.Get24HourVolumesAsync(symbols);
            var tradeCountsTask = BinanceService.Get24HourTradeCountsAsync(symbols);
            
            await Task.WhenAll(pricesTask, volumesTask, tradeCountsTask);
            
            prices = await pricesTask;
            volumes = await volumesTask;
            tradeCounts = await tradeCountsTask;
            lastUpdateTime = DateTime.Now;
            
            Logger.LogInformation($"Loaded prices, volumes and trade counts for {prices.Count} trading pairs");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading prices, volumes and trade counts");
        }
        finally
        {
            isLoadingPrices = false;
            if (!_disposed)
            {
                StateHasChanged();
            }
        }
    }

    private async Task StartRealtimePrices()
    {
        if (isWebSocketConnected || _disposed)
            return;

        isLoadingPrices = true;
        StateHasChanged();

        try
        {
            // Load initial prices first
            await LoadPrices();

            if (_disposed) return;

            // Subscribe to real-time price updates
            var symbols = allPairs.Select(p => p.Symbol).ToList();
            priceSubscription = await BinanceService.SubscribeToPriceUpdatesAsync(symbols, OnPriceUpdate);

            if (priceSubscription is not null && !_disposed)
            {
                isWebSocketConnected = true;
                Logger.LogInformation("Real-time price updates started automatically");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error starting real-time price updates");
        }
        finally
        {
            isLoadingPrices = false;
            if (!_disposed)
            {
                StateHasChanged();
            }
        }
    }

    private async Task StopRealtimePrices()
    {
        if (priceSubscription is not null)
        {
            try
            {
                await BinanceService.UnsubscribeAsync(priceSubscription);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error stopping real-time price updates");
            }
            finally
            {
                priceSubscription = null;
                isWebSocketConnected = false;
                Logger.LogInformation("Real-time price updates stopped");
                if (!_disposed)
                {
                    StateHasChanged();
                }
            }
        }
    }

    private void OnPriceUpdate(string symbol, decimal newPrice)
    {
        if (_disposed) return;

        try
        {
            // Store previous price for comparison
            if (prices.TryGetValue(symbol, out var oldPrice))
            {
                previousPrices[symbol] = oldPrice;
            }

            // Update price
            prices[symbol] = newPrice;
            priceChangeTime[symbol] = DateTime.Now;
            lastUpdateTime = DateTime.Now;

            // Update UI
            _ = InvokeAsync(StateHasChanged);

            // Clear price change indicator after 1 second
            _ = Task.Delay(1000, _cts?.Token ?? CancellationToken.None)
                .ContinueWith(_ =>
                {
                    if (!_disposed && !(_cts?.Token.IsCancellationRequested ?? true))
                    {
                        priceChangeTime.Remove(symbol);
                        _ = InvokeAsync(StateHasChanged);
                    }
                }, TaskScheduler.Default);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error in OnPriceUpdate for symbol {Symbol}", symbol);
        }
    }

    private string GetPriceChangeClass(string symbol)
    {
        if (!priceChangeTime.ContainsKey(symbol))
            return string.Empty;

        if (!previousPrices.TryGetValue(symbol, out var prevPrice) || !prices.TryGetValue(symbol, out var currentPrice))
            return string.Empty;

        if (currentPrice > prevPrice)
            return "price-up";
        else if (currentPrice < prevPrice)
            return "price-down";

        return string.Empty;
    }

    private decimal GetPrice(string symbol)
    {
        return prices.TryGetValue(symbol, out var price) ? price : 0m;
    }

    private decimal GetVolume(string symbol)
    {
        return volumes.TryGetValue(symbol, out var volume) ? volume : 0m;
    }

    private long GetTradeCount(string symbol)
    {
        return tradeCounts.TryGetValue(symbol, out var count) ? count : 0;
    }

    private string FormatVolume(decimal volume)
    {
        if (volume >= 1_000_000_000)
            return $"{(volume / 1_000_000_000):N2}B";
        if (volume >= 1_000_000)
            return $"{(volume / 1_000_000):N2}M";
        if (volume >= 1_000)
            return $"{(volume / 1_000):N2}K";
        return volume.ToString("N2");
    }

    private bool FilterFunc(TradingPair pair)
    {
        if (string.IsNullOrWhiteSpace(searchString))
            return true;

        if (pair.Symbol.Contains(searchString, StringComparison.OrdinalIgnoreCase))
            return true;
        if (pair.BaseAsset.Contains(searchString, StringComparison.OrdinalIgnoreCase))
            return true;
        if (pair.QuoteAsset.Contains(searchString, StringComparison.OrdinalIgnoreCase))
            return true;
        if (pair.DisplayName.Contains(searchString, StringComparison.OrdinalIgnoreCase))
            return true;
        if (!string.IsNullOrEmpty(pair.FullName) && pair.FullName.Contains(searchString, StringComparison.OrdinalIgnoreCase))
            return true;

        return false;
    }

    private void OnRowClick(TableRowClickEventArgs<TradingPair> args)
    {
        NavigateToPairDetails(args.Item.Symbol);
    }

    private void NavigateToPairDetails(string symbol)
    {
        Navigation.NavigateTo($"/trading-pair/{symbol}");
    }

    public async ValueTask DisposeAsync()
    {
        if (_disposed) return;
        
        _disposed = true;
        
        // Cancel all pending tasks
        _cts?.Cancel();
        _cts?.Dispose();
        
        // Stop WebSocket subscription
        if (priceSubscription is not null)
        {
            await StopRealtimePrices();
        }
    }
}
