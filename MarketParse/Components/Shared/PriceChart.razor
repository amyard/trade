@using Plotly.Blazor
@using Plotly.Blazor.Traces
@using Plotly.Blazor.LayoutLib
@using Plotly.Blazor.ConfigLib
@using global::MarketParse.Services
@using Binance.Net.Enums
@inject BinanceFuturesService BinanceService
@inject ILogger<PriceChart> Logger

<div class="chart-container">
    <div class="chart-controls mb-3">
        <div class="row">
            <div class="col-md-4">
                <label class="form-label">Time Range</label>
                <select class="form-select form-select-sm" @bind="selectedTimeRange" @bind:after="OnTimeRangeChanged">
                    <option value="15">15 minutes</option>
                    <option value="30">30 minutes</option>
                    <option value="60">1 hour</option>
                    <option value="120">2 hours</option>
                    <option value="240">4 hours</option>
                    <option value="480">8 hours</option>
                    <option value="1440">24 hours</option>
                </select>
            </div>
            <div class="col-md-4">
                <label class="form-label">Interval</label>
                <select class="form-select form-select-sm" @bind="selectedInterval" @bind:after="OnIntervalChanged">
                    <option value="@KlineInterval.OneMinute">1 minute</option>
                    <option value="@KlineInterval.ThreeMinutes">3 minutes</option>
                    <option value="@KlineInterval.FiveMinutes">5 minutes</option>
                    <option value="@KlineInterval.FifteenMinutes">15 minutes</option>
                    <option value="@KlineInterval.ThirtyMinutes">30 minutes</option>
                    <option value="@KlineInterval.OneHour">1 hour</option>
                </select>
            </div>
            <div class="col-md-4 d-flex align-items-end">
                <button class="btn btn-primary btn-sm me-2" @onclick="LoadMoreHistoricalData" disabled="@isLoadingMore">
                    @if (isLoadingMore)
                    {
                        <span class="spinner-border spinner-border-sm me-1" role="status"></span>
                    }
                    Load Earlier
                </button>
                <button class="btn btn-secondary btn-sm" @onclick="RefreshChart">
                    Refresh
                </button>
            </div>
        </div>
    </div>

    @if (isLoading && chartData.Count == 0)
    {
        <div class="text-center my-5">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading chart...</span>
            </div>
            <p class="mt-2">Loading chart data...</p>
        </div>
    }
    else if (chartData.Any())
    {
        <PlotlyChart @bind-Config="plotlyChart" @bind-Layout="layout" @bind-Data="data" 
                     style="height: 500px; width: 100%;" />

        <div class="chart-info mt-2">
            <small class="text-muted">
                <strong>Data Points:</strong> @chartData.Count | 
                <strong>From:</strong> @oldestTime.ToString("yyyy-MM-dd HH:mm") | 
                <strong>To:</strong> @latestTime.ToString("yyyy-MM-dd HH:mm")
                @if (chartData.Any())
                {
                    <span class="ms-3">
                        <strong>Latest:</strong> <span class="text-primary">$@chartData.Last().Close.ToString("N2")</span>
                    </span>
                    <span class="ms-2">
                        <strong>High:</strong> <span class="text-success">$@chartData.Max(c => c.High).ToString("N2")</span>
                    </span>
                    <span class="ms-2">
                        <strong>Low:</strong> <span class="text-danger">$@chartData.Min(c => c.Low).ToString("N2")</span>
                    </span>
                }
            </small>
        </div>
    }
    else
    {
        <div class="alert alert-warning">
            No chart data available for @Symbol
        </div>
    }
</div>

<style>
    .chart-container {
        background-color: white;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .chart-controls {
        border-bottom: 1px solid #e0e0e0;
        padding-bottom: 15px;
    }

    .chart-info {
        border-top: 1px solid #e0e0e0;
        padding-top: 10px;
    }
</style>

@code {
    [Parameter]
    public string Symbol { get; set; } = "BTCUSDT";

    [Parameter]
    public int InitialMinutes { get; set; } = 60;

    private Config plotlyChart = new();
    private Layout layout = new();
    private IList<ITrace> data = new List<ITrace>();
    
    private List<CandlestickData> chartData = new();
    private List<KlineData> klineHistory = new();
    
    private int selectedTimeRange = 60;
    private KlineInterval selectedInterval = KlineInterval.OneMinute;
    private bool isLoading = false;
    private bool isLoadingMore = false;
    private DateTime oldestTime = DateTime.UtcNow;
    private DateTime latestTime = DateTime.UtcNow;

    protected override async Task OnInitializedAsync()
    {
        selectedTimeRange = InitialMinutes;
        InitializeChartConfig();
        await LoadChartData();
    }

    private void InitializeChartConfig()
    {
        plotlyChart = new Config
        {
            Responsive = true
        };

        layout = new Layout
        {
            Title = new Title
            {
                Text = $"{Symbol} Candlestick Chart"
            },
            HoverMode = HoverModeEnum.Closest
        };
    }

    private async Task LoadChartData()
    {
        isLoading = true;
        StateHasChanged();

        try
        {
            var endTime = DateTime.UtcNow;
            var startTime = endTime.AddMinutes(-selectedTimeRange);

            var klines = await BinanceService.GetKlineDataAsync(
                Symbol,
                selectedInterval,
                startTime,
                endTime,
                null
            );

            if (klines.Any())
            {
                klineHistory = klines.OrderBy(k => k.OpenTime).ToList();
                UpdateChartData();
                Logger.LogInformation($"Loaded {klineHistory.Count} klines for chart");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading chart data");
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private async Task LoadMoreHistoricalData()
    {
        if (isLoadingMore || !klineHistory.Any())
            return;

        isLoadingMore = true;
        StateHasChanged();

        try
        {
            var oldestKline = klineHistory.First();
            var endTime = oldestKline.OpenTime.AddSeconds(-1);
            var startTime = endTime.AddMinutes(-selectedTimeRange);

            var olderKlines = await BinanceService.GetKlineDataAsync(
                Symbol,
                selectedInterval,
                startTime,
                endTime,
                null
            );

            if (olderKlines.Any())
            {
                klineHistory.InsertRange(0, olderKlines.OrderBy(k => k.OpenTime));
                UpdateChartData();
                Logger.LogInformation($"Loaded {olderKlines.Count} additional klines");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading more historical data");
        }
        finally
        {
            isLoadingMore = false;
            StateHasChanged();
        }
    }

    private void UpdateChartData()
    {
        chartData = klineHistory.Select(k => new CandlestickData
        {
            Time = k.OpenTime,
            Open = k.Open,
            High = k.High,
            Low = k.Low,
            Close = k.Close,
            Volume = k.Volume
        }).ToList();

        if (chartData.Any())
        {
            oldestTime = chartData.First().Time;
            latestTime = chartData.Last().Time;
            
            // Update Plotly chart data
            UpdatePlotlyData();
        }
    }

    private void UpdatePlotlyData()
    {
        data.Clear();

        var candlestick = new Candlestick
        {
            Name = Symbol,
            X = chartData.Select(c => (object)c.Time).ToList(),
            Open = chartData.Select(c => (object?)c.Open).ToList(),
            High = chartData.Select(c => (object?)c.High).ToList(),
            Low = chartData.Select(c => (object?)c.Low).ToList(),
            Close = chartData.Select(c => (object?)c.Close).ToList()
        };

        data.Add(candlestick);
    }

    private async Task OnTimeRangeChanged()
    {
        await LoadChartData();
    }

    private async Task OnIntervalChanged()
    {
        await LoadChartData();
    }

    private async Task RefreshChart()
    {
        UpdatePlotlyData();
        StateHasChanged();
        await Task.CompletedTask;
    }

    public async Task AddRealtimeData(KlineData newKline)
    {
        try
        {
            var existingIndex = klineHistory.FindIndex(k => k.OpenTime == newKline.OpenTime);
            
            if (existingIndex >= 0)
            {
                klineHistory[existingIndex] = newKline;
            }
            else
            {
                klineHistory.Add(newKline);
                klineHistory = klineHistory.OrderBy(k => k.OpenTime).ToList();
                
                // Keep only relevant data based on selected time range
                var cutoffTime = DateTime.UtcNow.AddMinutes(-selectedTimeRange * 2);
                klineHistory = klineHistory.Where(k => k.OpenTime >= cutoffTime).ToList();
            }

            UpdateChartData();
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error adding real-time data to chart");
        }
    }

    public class CandlestickData
    {
        public DateTime Time { get; set; }
        public decimal Open { get; set; }
        public decimal High { get; set; }
        public decimal Low { get; set; }
        public decimal Close { get; set; }
        public decimal Volume { get; set; }
    }
}
